## Name Of the Application: Slack-Couch

## Tool used: 
    Vscode, 
    Next FrameWork,
    bun/npm [package-manger]
    ShadCn/ui components,
    Convex --> for Managing Our Database, Authentication.

## App start guide:
    - First naviagte inside the root dir: slack-chat/
    - Need 2 terminals:
        1. terminal_1 --> Runs the next application on localhost:3000 [bun run dev]
        2. terminal_2 --> Runs convex service, supports Auth and database [bunx convex dev]
    - any package installed 
        eg: bun add package-name 

## search with keyword "Issue:" to find potential issue with the Application.


## App progress:

[26th Sept 2024]
-- Have setup the next FrameWork and have also added ShadCn support, That provides configurable components.
-- New folder --> features 
    - created under src.
    - Holds a folder --> auth [ecerything releated to auth i.e hooks, api calls, components and screen]
-- Pages marked as "use client" --> means that page is a react component not a react server component
    - react component: 
        Rendered by the browser i.e the client, have access to react-hooks like useStatet and useEffect and DOM objects.
        use:
            - When need interactivity or dynamic content. Have to handle state and make API calls.
            - eg: search Functionality.
    - react server component: 
        - These are rendered on the server and sent to the client.
        - faster compared to client-rendered. No access to react hooks. 
        use:
            - no interactivity needed, pre-rendered HTML need to sent to client i.e static content.
            - blog post or product-list page --> After loaded no change or interaction needed.

[28th Sept 2024]
-- Completed the basic layout for SignUp and SignIn Page.
-- Using and setting up convex [Database Manager] --> ** This has to be always running in a seperate terminal, to have access to database **
    --> Convex is the real-time database. i.e as soon as you update the database in backend, it will refelect in the client.

NOTE:
-- If parents are "use client" i.e client component --> Doesn't necessary means all it's children has to be clien too.
-- They can have server component as children, as long as they are passed using children prop.

** Basic Routing in Next App:
    -- Under app folder --> crate a new folder eg: test --> add a new file eg: page.tsx.
    -- Thus, now the above file open at: localhost:3000/test
    -- NOTE: 
        - page.tsx cannot have named export i.e export const page = () => {...} 
        - It must have default export. i.e const page = () => {...} export default page;

** Implementing Auth using Convex Auth
    -- For Setting up convex --> follow the Docs. [https://docs.convex.dev/quickstart/nextjs]
    -- Just Follow the ConvexAuth Docs. [https://labs.convex.dev/auth/setup]
    -- Use Auth.js under the hood.
    -- Make sure you maintain the File-structure carefully and also Handles the import and export of Modules properly.

OAuth -> The user Clicks on a btn to signIn with third-party like Github, Facebook or Google Account.
      -> Once user Authenticate on Third-party, he is landed back to App dashboard.

-- Convex Auth helps in handling secrets between the third-party app and our backend.

-- Login Provider setup using Convex-Auth [https://labs.convex.dev/auth/config/oauth]
    1. For Github Login: [Configuration/OAuth]
        - You need to first register a Oauth App in your Github profile --> Developer settings --> Oauth --> register your callback url and app details.
        - Get the client Id and secrests that to be used --> Add to convex.
        - "useAuthActions" from convexdev provides --> SignIn and SignOut method that handles signIn and SignOut for the user.
    
    2. For Google Login:
        - Go to google cloud console. --> create project --> search "api & services" --> oAuth Consent --> external --> Fill in App Details.
        - Skip the app img upload & under authorized domian fill the Convex HTTP Actions URL. [convex dashboard --> settings -> URL & Deploy key] --> Skip everything and save it.
        - Once Done, create the creds, for Authorized js --> give localhost:3000 and for redirecting url, give the one from convex.
        - Once setup, Add the clientId and secret key to convex and add google to auth.ts file and It should work.

## Both OAuth Working with ConvexAuth. --> Awesome..

    3. Login with Creds: 
        - First, need to configure the auth.ts in convex folder --> Add Password provider.
          - This takes care of both signIn and Register User/signUp.
        - Next, You need to handle the Passoword login method.
        - ConvexAuth Password provider --> Includes Password Check with length, one caps and one specialCharater. i.e Tester@123

** Issue:
    -- All the provider github, google and Password seems to be working fine.
    -- Not sure, [** check **]
        Why it's making post call, on successful Authentication via password and signOut call.
    -- Work-Around:
       On redirecting using signIn and signOut method --> added window.location.reload() to refresh the browser url. --> makes a GET call.

[1st Oct 2024]
## Fix the user's name Field empty in Convex users table with Password Provider:
    -- With OAuth, the name column in user table is automatically populated. But with Register user, It is Empty.
    -- Fix:
        - In auth.ts under convex folder, add the Passoword<DataModel>({...})
        - Replace the normal Password Provider with this new CustomPassword.
        - This will fill that column in the user table.

NOTE:
    -- To Clear all users session --> go to convex dashboard --> clear all Auth releated tables.

NOTE:
    -- use interface for Handling Object that wraps multiple types of data. reference: sign-up-card.tsx
    -- Page.tsx in any route folder under app eg: auth folder, Should do default export of the component.
    -- Inside Components Folder, [ **This folder is created automatically when you use shadcn** ]
        -> ui --> Components from shadcn.
        -> convex-client-provider.tsx --> Links convex db with Our Next client.
    -- Inside feature,
        -> Feature wise we have folders. 
            eg: auth --> contains all it's component used, type files and service calls.

[2nd Oct 2024]
** Creating the Profile Button:
    -- new Component Added --> user-button.tsx under feature/auth/component
    -- shadcn component used --> avatar, dropdown-menu

## How to handle fetching the current loggedIn User Details...
    - Under convex --> Create a new users.ts file --> export the query method from there.
    - Create a custom Hook --> under feature/auth/api --> use-current-user.ts --> That brings details of the current loggedin User.
    - Now you add this custom hook, whereEver you want to fetch current user details.
    - Logically, 
        - We need to get the current LoggedIn user details.
        - In users.ts [under convex folder]
            - We use getAuthUserId(ctx) --> Gives us the logged in User's Id.
            - then to fetch the details, we use ctx.db.get(getAuthUserId) --> gives the details of the loggedin user.
        - In Custom-hook: [under feature/auth/api]
            - To make the call, useQuery -> pass the api.[folder_name-you-created-above].[method-you-exported].
            - You have the data. --> use it as per need.
    NOTE:
        - Don't Forget to handle data as undefined [i.e It's Still fetching the data] and data as null -> No Response from DB.

NOTE:
    - From Component Files we can named export. But from page.tsx, we always need to default export.

MileStone_1: 
    -- We are able to Login using Password, OAuth [github and google].
    -- We have a signIn and SignUp Page Built, With Input Validations and Database connected.
    -- We are able to Naviagte to our Home Landing Page, have Profile Badge Implement.
    -- Logout Functionality is Also Implemented.


** WorkSpace Creation Api and Modal: 

    -- New Table creation: [convex/schema.ts] --> Workspaces --> holds the name of workspace, who crated it and joinCode.
    -- install new package:
        1. jotai --> global state management.
        2. dialog --> From shadcn, ui component
    -- Write a workspace.ts [in Convex folder], then call the query from feature/workspaces/api/use-get-workspaces custom hook.
    -- Logically, In Landing Page,
        - If workSpace exists -> Go to that WorkSpace.
        - If workspace doesn't exist --> Open a modal for user to Create a Workspace.

## Create a Global state For the CreateWorkspaceModal with joti
    -- First create a new file --> feature/workspaces/store/use-create-workspace-modal.
    -- Then useAtom and atom from jotai and return the state.
    Why ?
        --> Basically to handle the modal, we can simply use useState boolean to handle it.
        --> But useState will be specific to that component alone.
        --> But with jotai, You just made a global state to control the modal state. *** coool ***

-- Now, Create a new component for the create Workspace Dialoge Modal, Add it in the Layout.ts under src/app.
    --> Better Way to handle more Modals:
        - create a new modals.tsx under src/app/components.
        - import all the modals, --> have a component that renders all the modals.
        - Add this in the layout.tsx file. 
    NOTE:
        To Prevent hyderation error with jotai, When they gets render with server-side my mistake.
        --> Solution: Make Sure the modals folder is client rendered --> useEffect and "useClient" Make it for sure client rendered.

## Create an api end point to handle creation of workspace:
    1. Handling the DB Insert:    
        -- we will go to convex/workspace.ts --> add a new method createWorkSpace.
        -- This will be mutation method i.e updating existing table.
            NOTE: use query method when you are just reading from the table.
        -- This Works with an args --> That is passed as param to the handler method.
        -- Returns the newly created workspaceId.
    2. Handle the api [contains workspace related hooks] under feature/workspace/api:
        -- use-get-workspaces: Fetches all the workspaces for the current loggedIn userId.
        -- use-create-workspace:
            - Very powerful custom hook.
            - Goal: To handle creation of new Workspace, all gives us the API states, like 
                    isPending [time taken for the cration of workspace] --> used to diable the buttons and input fields during workspace creation.
                    isSuccess -> Returns a success method, that holds the response as param. --> Can be used to determine what to do when the creation is successful.
                    isError -> In case of error --> holds the Error Object as param. --> Can be used to render a Error fallback screen.
                    isSettled -> Once the call is done, If any action, this method can be used.
        
        *** IMP: Best Example, how to write and use a Complex api custom hook with nextJs and Convex *** [use as reference]
    3. A WorkSpace Landing Page:
        - New folder added under app/workspace--> [workspaceId]/page.tsx  [** This is how dynamic rounting handled ***]
        - eg: /workspace/34242424 --> lands to the the above page.
        - that id can be extracted in PageProps Interface {params: {workspaceId: string}} [Note: The name here and the above in dynamic route must match]

TODO: [3rd Oct 2024]

** Workspace Landing Page:
    
    -- A new folder under src/hooks --> Holds the application level hooks.
    -- A new hook added: use-workspace-id.ts --> It extracts the workspaceId that is passed in Params and Returns it. 
    
    ** NOTE: 
        1. Make sure the above one it's a client component. 
        2. useEffect, useParams --> This will not work if you dont mention the file as "use client".
        3. "use client" --> Marks the boundary between a server-side rendered component and client-side rendered component.
            -- i.e once in parent component, you mark 'use client' --> and it renderes subsequent children components.
                --> then untill specified, all children will follow 'use client', and no need to explictly mention them inside each children component.
                --> thus, once you cross the boundary, you are good.
                --> Ref: src/workspace/[id]/layout --> our parent component --> that render all it's children like sidebar, toolbar etc. [we dont have 'use client'] --> but we are able to use hooks and state management.
            -- Interactive websites tends to follow majorly clinet-side rendering.
            -- Static read-only websites like blog posts, List of Itenary etc, where no user-interaction necessary can be server-side rendered. --> Just display Data to the user. 
        4. If a page is "use client" --> And it renders others children using the children prop --> Doesnot mean all children will be client rendered, It can be server-rendered also as long as "children" prop is used to render them.
    
    -- A new db api added in convex/workspace.ts --> getById --> Fetches workspace Info based on passed workspaceId.
    -- To Make the above call, create a customHook --> under feature/workspaces/api --> useQuery and fetch the data and apiState.
    -- In the [workspaceId]/page.tsx --> Make the Above call to fetch workspace releated Data.

    NOTE:
        -- Page.tsx is a reserved keyword in nextJs to build the landing Page.
        -- layout.tsx is also a reserved keyword to handle layout within the same route.
        -- Other reserved keywords: error, loading. EXcept these you can keep whatever file you want inside route folder.
    
    ** Why Layout Needed ? --> ** Handles Common code between subRoutes **
        -- somtime, We have reusable code, Inside the under same route. 
            eg: under /workspace/[workspaceId] --> we can have many routes. like workspace/[workspaceId]/channel or workspace/[workspaceId] etc
        -- So the layout holds common code like, sideBar or navbar that we want both of the above.
        -- Layout dont get re-render on Route chnages. --> Big Performance Improvement. [** IMP **]
        -- So To minimise code duplication and improve modularity, It's suggested to go ahead with layout 

TODO: [5th Oct 2024]

## Handling Layout for Workpace [app/workspace/[workspaceId]/layout.tsx]
    -- Like Page, It also requires a default layout. **IMP**
    -- Children:React.ReactNode --> Need to be added inside layout, so that it renders others route paths i.e [workspaceId]/page.tsx inside the parent Route [/workspace].
    -- Now, Add the common code among the Routes inside this layout.
    NOTE: Page.tsx and layout.tsx both will be under same Parent.

    1. Create a Toolbar:
        -- created --> /workspace/[workspaceId]/toolbar.tsx.
        -- Add it to the layout.tsx
    
    2. Creating a SideBar
        -- created --> /workspace/[workspaceId]/sidebar.tsx.
        -- Add it to the layout.tsx
        -- Include workspace-switcher component --> Have DropDown, Allows user to switch between the workspaces.
        -- Features of workspace-switchers:
            - Allows user to view his active workspace, along with other worspaces. [NOTE: all workspaces will show here.]
            - Allows him to navigate to a particular workspace.

** Issue: [Fixed]
    -- When we create a new Workspace --> it's redirecting to the new workspace -> but the click events on the entire page is not working.
    -- It is Woking when, we force reload the page.
    -- Problem: In create-workspace-modal.tsx file,
        --> After fetching the new workspace data, we are navigating using router.push from next/navigation.
        --> Seems like this is removing the events.
        --> no Error on the console.
    -- WorkAround,
        --> Instead of using router.push --> use window.location.assign() --> Navigates and reload the whole page. [** costly operation **]

    -- sol:
        -> If you using a dropdown + dialog --> Where you create the new workspace --> In DropdownMenu add propery modal={false}.
        -> should solve the events disabled issue.

    3. Sidebar buttons:
        -- created --> /workspace/[workspaceId]/sidebar-button.tsx.
        -- Shows various Buttons on the Sidebar with dedicated Icons and Functionality.
    NOTE:
        -- If using shadcn, and you need to conditionaly use tailwind classes. --> use cn()
        -- For reference: sidebar-button.tsx
        -- why ? 
            -- alternative way of doing that like {`isActive ? 'classes if it's true' : 'classses if it's false'`}
            -- High chances of getting conflict and might cause error.
        NOTE: *** shadcn must be installed ***

NOTE:
    -- the api, calls that we do for fetching data, Next not everytime, makes a call --> the response is usually cached. 
    -- Only when some chnages hanppens in the backend then only It makes a new call to fetch the data. 
    [Performance efficient]


NOTE: ** Important JS/React Things to Remember **
    -- const {data:workspace, isLoading:workspaceIsLoading} = Obj.
        --> here you destructure data and isLoading from Obj and also respectively renamed them. [** Awesome Implementation of JS **]
    -- eg: const [_open, setOpen] = useSomeHook();
        --> '_' infront of open is a way to say that, I am not going to use that varibale in the code.
    -- While defining interface for props for any component, If a prop is optional, define it like..
        interface DummyCompProps {
            prop1: string;
            prop2: boolean;
            prop3 ?: boolean;
        }
    --> In the above example, prop1 and prop2 are mandatory but prop3 is optional.

## Implementation of Member Functionality:
    -- New Schema Created --> members
    --> Each User will have it's own member profile --> That tells us about 2 things:
        1. the workspace he have access to.
        2. What kind of access he have ? "Admin" or "Member".
    -- Schema Changes to handle add data in members table, and query data from member table. --> convex/workspace.ts
    -- Code generation should be random, instead of some fix values.

    Functionality:
        -- If a user creates a new workspace --> He should be added as "Admin" to the memebers table.
    NOTE:
        -- Creating index while defining Schema --> helps to query faster. Ref --> convex/schema.ts
        -- For FetchData with "query" keyword in convex/workspace.ts --> Dont throw error, instead return empty value or null.
        -- For Creation with "mutation" keyword --> you can throw error. 

    Conclusion:
        -- users can create different workspaces and he can only view those workspace which he created.
        -- JoinCode is randomly generated, instead of hardCodded.

## Workspace sidebar Component: 
    -- new shadcn component added -> resizable. [provides resizable containers]
    -- channel Sidebar is added in app/workspace/[id]/layout.ts
    -- New component under app/workspace/[id]/workspaceSideBar.tsx
        -- New Query file --> under convex/members.ts.
        -- handle api:
            1. fetch the current member details based on loggedin UserId and WorkspaceId.
        -- New Members folder added -> under src/feature/members.
            -- new api folder --> use hook to handle the above fetch current member details.
    -- We need to handle the member and workspace calls and handle the fallback and loading screen accordingly.
    -- New shadcn component --> tooltip, new file created --> src/components/hint.tsx

NOTE: 
    -- "Jotai" --> the package that we use to maintain the state of Create-Workflow modal State throughout application.
    -- This needs proper Initialization in a next.js env.
    -- Added a new file under --> src/components/jotai-provider.tsx
    -- In src/app/layout.tsx i.e the main Layout --> Wrap the Children inside the JotaiProvider.

## Channel-sidebar Preferences: - src/app/workspace/[id]/preferences-modal.tsx
    -- Why ?
       --> Provides user Option with Renaming Workspace Or Remove Workspace --> Manage the Workspaces.
    -- preferences-modal.tsx --> New file added under src/app/workspace/[id]/preferences-modal.tsx.
    -- This will be included in the workspace-header.
    -- new update Workspace API [** handles updating workspace metaData i.e workspace preferences **]
    -- new remove workspace API.
        NOTE: When we remove a workspace --> all related entries and members associated with that workspace in members table --> must be removed.
    -- Remove Workspace..
        --> Ask User For Confirmation before deleting the workspace. --> customHook --> src/app/hooks/useUserConfirmation.tsx
            -- This is a generic Confirmation Modal custom-hook.
            -- Allows user to pass custom-message and Confirmation Title, and returns Promise based on user's selection.
            -- Ref: preferences-modal.tsx --> confirmation before deleting a workspace.
        --> once deleted Successfully, Dont keep the user on the same workspace, Re-direct him to '/' route. --> this will load the app/page.tsx --> Which loads the first active workspace under the current LoggedInUser.
    
** Issue: [fixed]
    - Say we are working with Dialoges and 
    - In my parent Component am maintaining a state that tracks the opening and closing of the dialoge.
    - Now I have another component that Where I used the dialogue and acception the states from parents as props.
    Problem:
        - the dialogue will open fine, On click on the Dialoge Trigger btn.
        - But when the dialogue will close, This is removing all the btns and click events from the Page.
        - then we need to reload the whole page, In order to click on the Dialoge Trigger btn again.
    
    Possible WorkAround: Ref: workspace-header.tsx [parent] --> preferences-modal.tsx[child that has Dialoge]
        - onOpenChange --> Pass a function that close the Modal, as well as reload the current page.
        - Drawback --> Very Costly Operation, The whole page is refreshed. ** Worst **
    
    ** Solution Found: 
        -> Problem was with dropDown + Dialog box implementation.
        -> Solution: In DropdownMenu --> add a property of 'modal' as 'false'.

NOTE:
    -- While working with Dialog from shadcn, use asChild attribute when you have big code inside the Trigger or content or footer.
    -- this prevents hyderation issues.
    
*** How to handle custom user Confirmation Hook *** [ VIMP ]    
    -- Very unique way of handling User-confirmation Modal using promises. [Ref: use-user-confirm.tsx]  **IMP**
       --> basically have a promise or null as state.
       --> one confirm should initialize the promise in the state, and cancel should make state null.
       --> Based on state is null or not --> show the confirmation Modal.
       --> If Cancel --> Make the promise in the state as resolved --> with false, if confrim --> resolve it with true.
       --> Reset the state to null --> this closes the confirmation popup.
       --> retrun The ConfrimationPop component and confirm method. 
       --> In Parent, confirm method opens the popup --> wait for the user to confrim/cancel --> i.e once resolved --> Either will true/false --> based on this, Operation can be handled in Parent.

--> workspace Admin can successfuly edit or remove the current workspace using Prefernces dropDown Option.

TODO: [12 Oct 2024]
## Channel-sidebar Show and Add new members:
    -- new SideItem Component Added --> contains ButtonLink with custom Variant --> Navigates to Channel id.
    -- Creating Channels
       -> New Schema Created --> channels --> Holds name, id [workspaceId] 
       -> also new index added to query by workspaceId.
    Rules: Everytime, we create a Workspace -> We must have atleast 1 Channel. --> Create a new Channel when we create a new workspace. -> Ref: createWorkspace method under convex/workspace.ts 
    -- Now channel function is ready --> create the hook to fetch those values.
       -> New file For Channels --> src/features/channels/api --> useGetChannels.ts [new hook]

    -- Wrap the Whole channel part inside it's workspaceSection --> To Seperate it from Other sidebarItems.
    -- It should show a Plus Icon to Add New channels with a hover Text.
    -- Also It should either hide or show all the Channels.
    -- New Package Added -> react-use  --> gives us a bunch of useful hooks --> WE will use useToggle hook.
    -- New Function Added -> under convex/members.ts --> fetch all the members for that workspace.
    -- Intergated in workspace-sidebar with workspace-section and user-Item component.


## Implentation of Add functionality for Channels and Members in sideBar.
-- What is Channel ?
    --> A table in backend that stores name of the channel and Workspace.
    --> So basically a user [only Admin] can create multiple channels and Add multiple members to that channel ?
    -- Created a Jotai --> global toggel For Add channel modal. ref: src/feature/channel/store/use-create-channal-modal.tsx.
    -- Create the Add Channel Modal --> under feature/channel/component/create-channel-modal.tsx.
    -- Since we managing all our modal at one place.
        -> will Add the new Modal to modal.tsx file under -> src/components/modal.tsx
    -- feature/Rule for new Channel Name:
        -> All words should be in one go i.e no spaces, if spaces convert them to '-'
    -- Craete a api end-point i.e convex function and use-create-channel hook -> Need to be created.

Thus, Able to Add new channels and list them under the side-bar. 


** Issue:  [fixed]
    -- SO the issue, Of Dialog box after closing, all the events are going away on the page. 
    -- It is not a problem with dialog box, It's a problem with the dropDown menu from shadcn.
    -- When using dropdown --> It opens the dialog box --> After the dialog box closes --> All events in that page is gone.
    -- It is happening whereever am using dropdownMenu + dialog from shadcn.
--> Github Issue Link: [https://github.com/shadcn-ui/ui/issues/468]

Finally: Solution: 
    --> In Dropdown menu --> Add a property of modal as 'false' If you are using DropDown Menu and on menu Click Opening a Modal.
    
[17th Oct 2024]    
## Invite new Members Modal: [OnClick -> Invite members to current Project in sidebar]
    -- User Should be able to see a modal Window, With a Workspace Join Code and Copy the link to Join the Workspace.
    -- User should be able to reset the Join Code. [workspace.ts --> newJoinCode method] --> New hook created --> Used In invite-modal.ts

## Join Workspace Screen [New Members can join through this page]
    -- Changes in the workspace.ts --> New Mutation called join --> takes JoinCode and WorkspaceId as args.
        -> checks if the curr user is loggedin.
        -> Checks if the specified worksapce exists.
        -> checks if the joinCode passed in param belongs to given workspace.
        -> Check is the loggedIn user already is an existing member of this workspace.
    If all Conditions agrees, Create a new Entry in the members table for the current loggedin User and workspaceId in member table. 
    -- Create a new custom hook --> use-join.ts --> calls the join Convex server function from the workspace.ts.

[** NOTE: This is how we create new dynamic Routes in Next Framework **]
    -- New Folder to handle the join Routes  --> under src/app/join --> [workspaceId] a dynamic folder --> page.tsx [** This is how we create new Routes in Next Framework **]
        -- Make sure the case and spelling of the dynamic Route is correct. Else useWorkspaceId.ts custom hook wont be able to pick that Id from url with useParams.
        -- Also Page.tsx must be default export.
    -- For Logo and any image --> We store it in public Folder outisde the src folder.
    -- We want a verification Input Box For user to type the code. [** New Package Added --> react-verification-input]
    -- If the current Loggedin user is already a member of the Workspace --> redirect him to his workspace 

Conclusion: 
    -> Login With Account1 --> Go to a Workspace --> Select Invite Members --> Copy the code and url --> logout.
       NOTE: If you try to paste the copied url --> You will be redirected back to home screen [since you are already a member of the workspace]
    -> Now -> Login with Account2 --> Paste the copied url --> Paste the Code --> Now user of Account2 have access ot Account1's Workspace. [as a member].


[19th Oct 2024]  
## Channel page 
    -- When any user Visit a workspace --> atleast 1 channel or the default General Channel must be active & One Member must be selected.
    -- Cretaed a new custom hook unnder src/hooks --> use-channel-id.ts --> extract the channelId form the params.
    -- new Route --> under src/app/workspace/[workspaceId]/channel/[channelId]/page.tsx
        NOTE: since channel's page.tsx is inside workspace/[workspaceId] --> It shares all it's layout --> Thus Saves from unnecessary re-renders.
    -- Modify the workspace/[workspaceId]/page.tsx
        --> It checks for the channels and workspaceData --> and accordingly handles the naviagtion to that workspace or open a new Channel Creating Popup.
    Now, 
        If you go to a workspace with no Channels --> It will prompt to add a new channel --> Once Created --> It will naviagte to that channel Landing page..
        And the Active channel must be highlighted.
        And If we create a new workspace --> It should automatically naviagte to the new Channel workspace --> also Highlight the same in the side-bar.

    BugFix:
        --> You Go to a workspace --> Where you are not an Admin and also it doesnot have any Channels.
        --> There, You will stuck with the Add New Channel Screen --> as You are not the admin, You wont be able to create any channel, also No Channels, it will keep on Showing the create channel popup.
        Sol:
            -> In Page.tsx of workspace/[workspaceId] --> Get the member details using hook --> Check if it's Admin.
            -> Open the create Channel Popup only if it's an Admin.
            -> If not show a error saying, Channel Not found.

** Issue:  
    -- So Lets say, You loggedin With Account1 --> workspace W1 --> Copied the code and link to join the channel --> Loggout.
    -- Login with account2 --> Paste the link and joincode --> Redirected back to joined workspace W1
        --> Here, In W1, account2 is a member and no channel is selected.
        --> thus, It wont show the create channel popup or it will navigate to the first workspace
        --> It will show No Channel Found Error --> as you naviagted to a workspace but haven' selected any workspace.
    Expectation:
        --> Ideally, It should naviagte to the first channel it is getting automatically.
    Expeected Sol:
        --> In page.tsx of workspace/[workspaceId] --> If the current loggedIn User is not Admin
        --> He should be re-directed to the appropiate shared channel.
        --> If No Channel Found, and he is not an Admin --> Error Message display a No channel Found or selecteed.

## Channel Page Header
    -- new convex function under channel.ts --> fetches the channel Details based on Id.
    -- The user, If admin should be able to Click on the channel header --> Opens a Dialog Box --> Can Edit Channel Name and Remove the Channel.
    -- new Methods added to handle the --> Channel Update and Channel remove [channel.ts]
    -- new Channel-header --> under page.tsx [Channel/[channelId]] --> uses nested Dialog Box to show Edit Channel Modal and Open the Edit Channel Popup.

## Editor Component
    -- New Component Created --> chat-input.tsx under page.tsx of channel/[channelId].
    -- New Reusuable Component --> Editor [** under src/components --> we are going to use it at many places **]
       NOTE: ** Default export the EDitor component **
       Reason: We will be using dynamic Import in ChatInput component --> that's why default export is needed.
    -- We will not Develop the Editor from Scratch.
       - new Packages added: qill [editor package]
       - Configure Editor with quill and dynamically add it in a div using useRef and useEffect. [ Reference: editor.tsx ]
       - Update global.css file, for styling the editor. NOTE: all css property must be !important --> Overrides the default styles from qill package.
       - Basically, We Overrided few of the inbuilt style classs by quill like ql-editor, ql-container etc in global.css ---> 'ql-custom' on the editor container implements these custom styles.
       - quill doesnot support server-side rendering.
          Solution: In chat-input.tsx --> use dynamic from next/dynamic --> dynamically load the editor.tsx [contains qill editor].
    -- Editor component is a very re-usable component --> We can accept props and based on that --> We can add multiple Variant of the editor [For New Message/Edit Messages]
        Variant: Create Or update.
            -- For Update, We will not show the attach image Option.
            -- submit button for create and [save and cancel] buttons for Edit Case.
    -- using useRef hook heavily to avoid Screen rendering and also not have to pass dependecy to useEffect.
    -- New React hook used: useLayoutEffect [No Dependency Array need] --> updates all the refs.
    -- working with refs and useEffect Efficents:
        placeholder value in Prop --> the useRef hols the value --> can directly use it in useEffect, no need to add in dependecy array.
    -- using a mix and match of useRefs, useState and useEffect.
       NOTE: useRefs will chnage but it will not cause any re-renders, thus we need some state control over the messages we type in the editor 
            -> based on that we can perfrom any actions like disabling the send button or others.
    -- In Quill, Suppose you want to press enter to 'submit' or say want to add a newline when pressed 'shift + Enter'
        --> Modify the options in the useEffect, For Quill.
        --> Baiscally In modules property --> We can control toolbar, keybindings etc. Reference: editor.tsx
    --> We have kept whatever items we need in the toolbar using quill option, module property.
    --> We have also Modified the use of "Enter" Key and "shift+Enter" Key press for the editor. --> using the quill option, module keyboard property.

 WE have a working Editor with Add Message and edit Message functionality.


TODO: [30th Oct]
## Editor Functionalities --> 

# Emoji Picker
    -- New Package added - @emoji-mart/react, @emoji-mart/data.
    -- New Shadcn Component added -> Popover
    -- New Reusable component added - emoji-popover.tsx under components [Can be used for Emoji wherever needed]
    -- We could have used Hint for the Popup: [** How to handle popover for Emojis using popover + tooltip **]
        -> Not a good idea, --> rather we have write the popover code from scratch using toolTip and popover component.
        -> Reference: emoji-popover.tsx -->  using toolTip component inside the popover component.
    
    Thus we are able to add an Emoji picker ==> Gives the Emoji and Adds at the end of the text in the Editor.


TODO: [17th November]

# Image Picker:
    -- to handle image state --> we added 2 things: 
        1) One is a state variable and 
        2) another is a Img ref that can be used to extract the img from useEffect -> saves us any re-renders for the Editior. 
    -- Concept of Phantom Input:
        - Requirement, I should be able to open the File select window when i click on Image Icon.
        - Solution:
            1. create a input that accepts Images. [type: file] --> Make sure it is hidden and my imageRef point to this element.
            2. Next onClick of the image Icon --> Call the click method of the imageRef from above. --> This mimic the click on the above input element.
        - Thus, We are not actually clicking on the Image element but using Ref we are still able to mimic the click on it. [** phantom input **]
    -- Any File type evt --> has target --> files and value.
    -- Note: The css position is used to confined the delete button and the image within that space.
    -- For removing the image --> We are removing the image from the state, And Making the ImageRef.current contains Empty Value.
    -- For Now we are able to upload only one image.

    Thus, Image Upload Works.


MileStone_2:
    -- Now we are able to create a New Workspace and Land to that Workspace Route.
    -- Created the toolbar/navbar and sidebar UI. 
    -- Diffenet users with can create and view their own workspaces.
    -- workspace Admin can update workspace name or Remove the current workspace.
    -- Now we are able to view Channels [For newly created Workspaces] and Associated Members Options in the sidebar.
    -- Users able to Invite other Members, Other Members can join Other Workspaces [using shared links and Code] 
    -- User is able to Update Channel Name and Remove Channel From Channel Header.
    -- Created a Editor Box using quill, Supports Add/Edit Messages with toolbar for text formating.
    -- Emoji Picker and Image Upload is Implemented using @emoji-mart/data, @emoji-mart/react, popover+toolTip component.
    


Date: [22nd June 2025]
## Editor Submit Feature:
    -- The submit event is being handled at chat-input.tsx -> editor.tsx [child component]
    -- New "message" table is added in the convex schema.
        -> REcords messages sent in the server throught workspace or part of any channels.
        -> Includes replies to another messages.
        -> conversation Messages. [TODO]
    NOTE:
        -> Images are stored as v.id("_storage") --> I guess convex stores multi-byte data in this manner.
    -- create a new method, to create a message with convex db under convex folder.
    -- We will use a hook to handle this api call. --> under src/feature/messages folder.
    -- Data Flow:
        -> we call custom hook --> hooks call convex methods --> contex methods call ctx db functions.
    -- Here we are successfully able to insert the desired message in the DB.
    
    # Image Upload Functionality:     
        - we should be able to upload the image in convex and store the link to it.
        - Concept:
            - convex has file storage with v.id("_storage") --> stores as storageId.
            - upload the image here --> get an url using ctx.storage.generateUploadUrl() method.
            - Do a fetch call to get details of the image --> fetch the storageId.
            - Store image storageId for reference in Our Message DB for refering to any attached image with message meta-data.

    # Schema Creation:
        - Complete the whole schema model for the Slack Couch Chat App.
        - Added 2 new tables Definations:
            1. conversations -> store converstation Ids between 2 people.
            2. reactions -> stores reaction for a message.
        - Also added it as optional Table column in Messages Table defination.
        - Do add indexes in schema for querying messages and conversation details.
        - Handle the case with conversations:
            - message.ts -> handles message create operations.
            - NOTE: handle a special case when we are replying in a thread in 1:1 conversation.
                    -> This message wont be a part of channel or any conversation. i.e channelId or conversationId wont be present.
                    -> but it will have a parent message id.

Date: [23rd June]
## Messages and MessageList Component:     
    # Messages GET API:
        - For handleing messages, we need to handle a method to load the thread info.
        - threadinfo, includes message's Replies, Author info, timestamp etc Ref: messages.ts helper-fucntions.
        - get messages API: 
            - we should be able to fetch message based on channelId, converstaionId or parentMessageId.
            - Also we need to pagination while fetching messages.
            - For including pagination with Convex:
                in Query, in args, use paginationOpts: paginationOptsValidator.
            - Handled the get call for the messages, [Make sure you handle the special case of 1:1 conversation thread]
            - created hook use-get-messages to handle the paginated response.
                -> inside only handled the batch size and convex's paginationQuery call.
        -  Integrate the get Message API, to fetch information of Reactions, thread details, users, members. --> helps us to get enough data to just render in ui.

    # Message List Component:
        - Under ChannelId's page.tsx --> You fetch messags now based on channelId.
        - Renders a seperate re-usable component to messages.
            -> All messages pops up here from the botton i.e flex-col-reverse.
            -> We will group the messages based on time when they are send with a seperator.
            -> needed a bun dependency -> bun add date-fns. [** New dependency added **] --> used for date formatting.
            -> the above dependecy is used like to show date label like today, yesterday or date format for the message groups.
        - A message Component to render each messages body.
        - A render component:
            - read the body of the message from Quill editor and display the message.
            - The render is used to dynamically insert QillEditor, This is because the formatting will be preserved.
            - In the text it will exactly show how it appears in Quill Editor.
        - Also, we wawnt to show the message creation Time with a Hint menu.
        -  we have 2 view for message:
            compact view -> a nice short message text view with time.
            default view -> see the author's image, name and text message.
        Case:
            -> If the user sends messages one of another, then the susequent messages will be compact view.
            -> else it will be default view [the first message of the user]
            -> Logic: If current-message and prev-message has same user and diff between creation is 5 mins.
        -> Also Show an image, if image is present. --> thumbnail.tsx
        -> When clicked, show the image in a dialogbox.


### Major Fix:  -> [False Fix]
issue: Get messages API from convex was returning the default types instead of the types with updated message data
        like users, members, reactions, threadCount etc are missing.
Fix: [** NOT NEEDED **]
    - This is an issue from convex function, so we need to manually added the types of the data that we are expecting.
    - Updated the issue with filter in messages.ts --> get method for the page.
    - In use-get-messages hook, we are manually adding the additional types  + the base type that coming from api.messages.get._returnType.
    - Also added that as the results return type to solve type-checks issues.
    - We are using the above type for the message get response.

FIX: 
    - Convex is returning the correct type. My Mistake was that i was not awaiting the ctx.get.query("messages") in get method.
    - Fixed -> The types are coming correct, No need for any Enrichments and all.

        

    ## Channel hero Component:
        -  A Message header for every last message under a channel.
        - It is like a zero-state for a channel page. It will appear at the top of all the messages in every channel.

    ## Message Toolbase:
        - A message toolbar enables us to edit a message, delete a message and react to a particular message.
        - Activates when user hovers. [using group-hover tailwind css class]
        - Handles the visibility of different toolbar actions.
            -> Reaction button is visible always.
            -> Reply to thread button is visible only is it's not a thread.
            -> Edit and delete button will come only if you are the author of that message.
    
    ## Edit, delete and Reaction message funtionality:
        - feat:
            -> as the user clicks on the message action like edit,delete -> the message gets highlighted and the toolbar disappears.
        ## Edit: 
            - we have created new method under convex/message.ts -> update.
            - a new hook: use-update-message: updates the message.
            - dynmaically import the quill editor component --> choose weather to render the Renderer component or editor component.
            - How we know a message is Edited --> When edited we are populating the upadtedAt with current time.
            - Both compact view and full message view supports Editing.
        ## Delete:
            - we have created new method under convex/message.ts -> delete.
            - a new hook: use-delete-message: updates the message.
            - delete works as expected.
            - Bonus: added a colapse animation when deleted.
        ## Messages Reaction:
            - Needs reactions api to handle reactions. --> a convex method and a hook for the same.
            - a toggle method to toggle a reaction on a particular message.
            - Integrate the hook in messages.tsx for both compact form and default view form.
            - feat:
                -> you can see the reaction counts and the current user's reaction will be highlughted,
                -> click on the reaction to increase the count, click again to remove it.
                -> add raction face will be following up, to add new reaction on demand.

## Major Fix:
    Issue:
        -- Lets say In use-messages-get, you change the batch size to 3. --> it will get the last 3 latest messages.
        -- All rest of the messages in the channel will be not shown.
    
    Fix: Infinite loading 
        -- using view-port observer reactions. -> useIntersectionObserver hook on the ref of a div.
        -- from convex pagination, we get a loadmore function --> This loads more data in batches of pagination.
        -- also implement a loading indicator when we load more.

Date: [27th June]
    ## Thread Funtionality and Features
        -- new package: bun add nuqs [search params for url state manager for React]
        NOTE: package dependency:
            -> You need to wrap the RootLayout [src/app/layout.tsx] with NuqsAdapter --> then only it will work.
        -- To fetch the parent messageId from url: 
            -> We will fetch it from the url. [why? No need to manually check if a message in the correct channel or not, more realiable, easy and faster]
            -> using a hook to fetch the parent message Id with "nuqs".
            -> usePanel hook is used to handle parentMessageId in the url.
        -- If we have a ParentMessageId query in the url --> it will show another spliter for the showing thread.  
        -- How to Open the tread panel ?
            -> It should open when we click on Replay with thread from Message Toolbar. 
        -- Inside the Thread Panel:
            -> We will use the whole mesage List component -> to show thread mesages.
            -> We are working on this ThreadPanel view inside layout.tsx under the 3rd ResizablePanel view.
        NOTE: We will get string type from the url using nuqs but we need to manually define the type as Id<"messages"> for it work with convex. Ref: layout.tsx [under Thread component props]
        - Thread a new component will show the thread-view of messages.
        - created a new getById.
            -> Lots of validation before we allow anyone to get the message.
            -> a part from message details, we also include, reaction details [includes count and groups], member details and user details.
        - Display the message details at the top. of the thread component. --> Reuse the Message.tsx to show the same.
        feat:
            - If you are author, you are allowed to edit, delete the original message from the thread itself.
            - If you are just a member, you can only send reactions.
    
    ## Thread Editor and Chat:
        - we will bring the Editor component here...
        - Take reference from chat-input.tsx and have the similar functionality to create message and upload images.
        - For the Thread Chat view:
            -> We are going to refer message-list.tsx component [Why not reuse ? --> because of Scroll issues]
            -> implemetns the reverse chat list logic.
            -> implement the infite loader div while loading more messages.

## Converstaion Functionality.
    -- When you click on user's [user-item.tsx] --> It should redirect to memberId page.
    -- New route path we need to create in the project structure.
    -- To fetch converstaiton:
        -> Fetch currentMember Detail and the other member detail.
        -> Find any converstation that exists between this 2 members.
    feat:
        -> Click on any member of a workspace to have 1:1 conversation.
        -> That user's chat and chat history will appear.
        -> NOTE: Both the members must be the part of a common workspace.
    Bonus: You can talk to yourself too...
    -- Add a converstaion header for the asthetics...
NOTE:
    the special case here: 
        - When a user replies to a message inside a 1-1 conversation. We just have the workspaceId and memberId.
        - we dont have channelId or conversationId. --> So to get conversationId --> we have parentMessageId [since it is a reply]
        - this gives us the required conversationId while getting messages. [Ref: get method in convex/messages.ts ]
    
    ## Upating the thread bar component.
        - If a message has a reply, It will be easier to see from here.
        -  Threadbar Component handles this.
        - It shows image of the last user to reply on thread, time it was send. --> onClick --> it opens the thread window.

## Mmeber Profile Page
    - If user Image or name is clicked from the message list --> A right panel opens with member's details.
    - Take the profileMemberId from the url. -> use-profile-member-id hook.
    - In layout.tsx --> Either profileMemberId or Thread or ParentMessageId will be there in query params.
    - Thus the right panel switches between profile view or thread view.
    - It shows image, name and the contact details of a member.
    - Profile.tsx shows the right panel.

## Update Member Role to Admin and Kick Member Functionality:
    - New API for update Member and delete Member Functionality [convex/members.ts]
    - Few Rules For updating and removing:
        updating:
            - If the current user is not an Admin, you cannot change role of other users.
        removing:
            - YOu cannot remove an admin.
            - YOu cannot remove yourself if you are the admin, otherwise, you can..
            - When we remove a member, We need to remove all linked messgaes, conversations and reactions.
    - New Hooks created for handling update Role and Remove member fucntionality.
    - feat:
        -> If an Admin is looking at someone's profile -> He can either edit his role or Remove him from chat.
        -> If a member is looking at his own profile --> Her can Leave the chat.
        -> If an admin is looking at his profile / A member is looking at admin's profile --> No Option is given.


## BugFixes:

    1. When a user leaves a workspace --> A all broken screen comes, He should bre redirected to a default workspace.
      Issue: 
        -> next-router naviagtion, is not refreshing and reloading the whole page. It re-directs without refreshing. --> Thats why we see a workspace and channel with Errors.
      Sol:
        -> Instead of next-naviagtion, we will use window.location.replace --> This will hard reload the page and also redirects the url.

    2. After dialog closes the screen freezes.
      -> Normally it works, Problem is when we have dropDown + Dialog box.
      Issue:
        -> shad-cn's dialog and dropdown, makes pointer-event to none, to prevent the user from intracting with backgroud event.
        -> when we click on drop-down, It immediatly opened the dialog, thus, no enough time to do clean-up and reset the pointer-cursor back to auto.
      Sol:
        -> Added a 200ms delay when change is done with the dropDown, Gives enough time to run clean-up for dropDown and then open dialog.





Additional NOTE:
    -- Lucide Icons can be passed as Props to Child component. Ref: In workspace-sidebar component, we are passing "MessageSquareText" Licude Icon as Icon Prop.
        -> In the child comp, You must define the type as LucideIcon OR IconType -> from react-icon/lib.
        -> Also, As you destructure the Props, make sure to Map it to a variable with Caps to use as Component. Ref: sidebar-item.tsx
    -- "asChild" Property example. 
        --> If a button holds a link, And button you mark asChild. --> the button will behave like a Link.
        --> Prevents hyderation errors.
    -- using Link from next/Link --> Navigates to a particular URL. takes href.
    -- while using convex functions. Ref: convex/channels.ts
        -> after you write the query and withindex Chain. --> use collect() or unique() depending upon if the query will return multiple or unique rows.
    -- ml-auto or anything ml/mr/mt/mb-auto --> Will take all the space available on that respective side.
    -- opacity-0 or opacity-100 on hover can be used to handle the visibility.
    -- While Destructuring Obj, you can give default value to any key like eg: cosnt {key1, key2 = "myDefaultVal" } = Obj;  [** IMP **]
    -- Working with implementing hooks. [** VIMP **]
        -> Any hooks implementation must be the first thing in any component body.
        -> Ex: In workspace-sidebar.tsx, if i put the useCreateWorkspace hook at the last, It will throw error.
          1. It's better to put such kind of state or any hooks at the top.
          2. then write all the hooks used for api call and data fetching.
          3. then write the logic or data manipulation.
          4. then return the body of the Component. 
    -- For Logos and Pictures, Use Image from next/Image --> Optimise the Image
    -- Other than using useParams hook to Get the path param, You can define an interface for the component and inside it use param object with the path paramId, to fetch the param details. Ref: src/join/page.tsx
    -- While Modifying the syles for Editor:
        -- In Global.css --> If you want to use tailwind classes inside css, use @apply tailwind-classname
    -- We can define types for the component Props by using 'type' keyword. --> this Object can be used inside 'interface' Component Props Object to define type for any Prop Key.
       Reference: editor.tsx, use-workspace-create.tsx etc [using 'type' with 'interface']
    -- If you have Optional Props, use like: CompProps { key1?: string;} --> this means key1 is optional for the Componant. By default, all props are mandatory.
    -- Generally, useRefs are used to create dynamic contents. --> Reference: editor.tsx
    -- Cool thing about Refs: [** VIMP **]
        1. They dont need to be added to the depenedecy array of the useEffect hook.
        2. If they change, It Doesnot cause the page to Reload.
        Ref: editor.tsx --> heavily depends upon refs.
    -- Refs can be used well with useEffect, but they cannot be used outside as they will not re-rendered if changed. [** VIMP **]
        Sol: use state controlled like useState or the props outside useEffect. Inside useEffect you can use refs.
    -- ESLint VSCode:
        - Basically, any framework like Nextjs comes inbuilt with .eslintrc.json Or you can add a new file that passes your code through a linter.
        - You can add a lot of options based on how you want your code to be linted.
        - we added 2 property, that suppress the error of unused-var for typescript.
    -- using regex while text matching...
        - Has to be .replace('/#####/g, '') --> ##### should be your matcher it will look for..
        - eg: .replace('/<(.|\n)*?>/g, '') --> This basically removes any tags like <br><div> etc..
    -- In Convex,
        Id<"schema_name"> --> when you need to specify Id type for a particular table.
        Doc<"schema_name"> --> when you need to whole content type of a particular table.


[** IMP **]
    -- Working with convex Functions: Ref: convex/members.ts
        -> If Your fucntion returns array of data --> Check case if resp is null --> return [];
        -> If your function returns a unique data or ID --> check case if resp is null -> return null;
    -- Handling Multiple Tables with convex functions. [convex/members.ts/get method]
        -> Querying members table, based on userId --> I want to fetch the details from the user tables.
        -> This takes the ctx and the id --> using the id, it will fetch the details from the respective table.
    -- For paginated Data with Convex:
        in the args, add paginatedOpts -> paginationOptsValidator.
        in the ctx.dab.query().withIndex().paginate(args.paginatedOpts)
        REf: messages.ts, use-get-messages.ts hook.
    -- JS knowledge,
       you cannot use async with .map method, but if you wrap it inside a Promise.all, you can use it.
       REF: messages.ts
    NOTE: Dont throw exceptions except unAuthorized in get methods. -> return null.
    

Note: [on shadcn]
    -- We can create our own variant for button using "cva" instead of multiple if-else.. Ref: sidebar-item.tsx 
    -- import { cva, type VariantProps } from 'class-variance-authority'; --> You can see they have done the same in button.tsx under components/ui.
    -- Cleaner way of defining mutiple styles for button.      