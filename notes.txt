## Name Of the Application: Slack-chat
## Tool used: 
    Vscode, 
    Next FrameWork,
    bun/npm [package-manger]
    ShadCn/ui components,
    Convex --> for Managing Our Database, Authentication.

## App start guide:
    - First naviagte inside the root dir: slack-chat/
    - Need 2 terminals:
        1. terminal_1 --> Runs the next application on localhost:3000 [bun run dev]
        2. terminal_2 --> Runs convex service, supports Auth and database [bunx convex dev]

## search with keyword "Issue:" to find potential issue with the Application.


## App progress:

[26th Sept 2024]
-- Have setup the next FrameWork and have also added ShadCn support, That provides configurable components.
-- New folder --> features 
    - created under src.
    - Holds a folder --> auth [ecerything releated to auth i.e hooks, api calls, components and screen]
-- Pages marked as "use client" --> means that page is a react component not a react server component
    - react component: 
        Rendered by the browser i.e the client, have access to react-hooks like useStatet and useEffect and DOM objects.
        use:
            - When need interactivity or dynamic content. Have to handle state and make API calls.
            - eg: search Functionality.
    - react server component: 
        - These are rendered on the server and sent to the client.
        - faster compared to client-rendered. No access to react hooks. 
        use:
            - no interactivity needed, pre-rendered HTML need to sent to client i.e static content.
            - blog post or product-list page --> After loaded no change or interaction needed.

[28th Sept 2024]
-- Completed the basic layout for SignUp and SignIn Page.
-- Using and setting up convex [Database Manager] --> ** This has to be always running in a seperate terminal, to have access to database **
    --> Convex is the real-time database. i.e as soon as you update the database in backend, it will refelect in the client.

NOTE:
-- If parents are "use client" i.e client component --> Doesn't necessary means all it's children has to be clien too.
-- They can have server component as children, as long as they are passed using children prop.

** Basic Routing in Next App:
    -- Under app folder --> crate a new folder eg: test --> add a new file eg: page.tsx.
    -- Thus, now the above file open at: localhost:3000/test
    -- NOTE: 
        - page.tsx cannot have named export i.e export const page = () => {...} 
        - It must have default export. i.e const page = () => {...} export default page;

** Implementing Auth using Convex Auth
    -- For Setting up convex --> follow the Docs. [https://docs.convex.dev/quickstart/nextjs]
    -- Just Follow the ConvexAuth Docs. [https://labs.convex.dev/auth/setup]
    -- Use Auth.js under the hood.
    -- Make sure you maintain the File-structure carefully and also Handles the import and export of Modules properly.

OAuth -> The user Clicks on a btn to signIn with third-party like Github, Facebook or Google Account.
      -> Once user Authenticate on Third-party, he is landed back to App dashboard.

-- Convex Auth helps in handling secrets between the third-party app and our backend.

-- Login Provider setup using Convex-Auth [https://labs.convex.dev/auth/config/oauth]
    1. For Github Login: [Configuration/OAuth]
        - You need to first register a Oauth App in your Github profile --> Developer settings --> Oauth --> register your callback url and app details.
        - Get the client Id and secrests that to be used --> Add to convex.
        - "useAuthActions" from convexdev provides --> SignIn and SignOut method that handles signIn and SignOut for the user.
    
    2. For Google Login:
        - Go to google cloud console. --> create project --> search "api & services" --> oAuth Consent --> external --> Fill in App Details.
        - Skip the app img upload & under authorized domian fill the Convex HTTP Actions URL. [convex dashboard --> settings -> URL & Deploy key] --> Skip everything and save it.
        - Once Done, create the creds, for Authorized js --> give localhost:3000 and for redirecting url, give the one from convex.
        - Once setup, Add the clientId and secret key to convex and add google to auth.ts file and It should work.

## Both OAuth Working with ConvexAuth. --> Awesome..

    3. Login with Creds: 
        - First, need to configure the auth.ts in convex folder --> Add Password provider.
          - This takes care of both signIn and Register User/signUp.
        - Next, You need to handle the Passoword login method.
        - ConvexAuth Password provider --> Includes Password Check with length, one caps and one specialCharater. i.e Tester@123

** Issue:
    -- All the provider github, google and Password seems to be working fine.
    -- Not sure, [** check **]
        Why it's making post call, on successful Authentication via password and signOut call.
    -- Work-Around:
       On redirecting using signIn and signOut method --> added window.location.reload() to refresh the browser url. --> makes a GET call.

[1st Oct 2024]
## Fix the user's name Field empty in Convex users table with Password Provider:
    -- With OAuth, the name column in user table is automatically populated. But with Register user, It is Empty.
    -- Fix:
        - In auth.ts under convex folder, add the Passoword<DataModel>({...})
        - Replace the normal Password Provider with this new CustomPassword.
        - This will fill that column in the user table.

NOTE:
    -- To Clear all users session --> go to convex dashboard --> clear all Auth releated tables.

NOTE:
    -- use interface for Handling Object that wraps multiple types of data. reference: sign-up-card.tsx
    -- Page.tsx in any route folder under app eg: auth folder, Should do default export of the component.
    -- Inside Components Folder, [ **This folder is created automatically when you use shadcn** ]
        -> ui --> Components from shadcn.
        -> convex-client-provider.tsx --> Links convex db with Our Next client.
    -- Inside feature,
        -> Feature wise we have folders. 
            eg: auth --> contains all it's component used, type files and service calls.

[2nd Oct 2024]
** Creating the Profile Button:
    -- new Component Added --> user-button.tsx under feature/auth/component
    -- shadcn component used --> avatar, dropdown-menu

## How to handle fetching the current loggedIn User Details...
    - Under convex --> Create a new users.ts file --> export the query method from there.
    - Create a custom Hook --> under feature/auth/api --> use-current-user.ts --> That brings details of the current loggedin User.
    - Now you add this custom hook, whereEver you want to fetch current user details.
    - Logically, 
        - We need to get the current LoggedIn user details.
        - In users.ts [under convex folder]
            - We use getAuthUserId(ctx) --> Gives us the logged in User's Id.
            - then to fetch the details, we use ctx.db.get(getAuthUserId) --> gives the details of the loggedin user.
        - In Custom-hook: [under feature/auth/api]
            - To make the call, useQuery -> pass the api.[folder_name-you-created-above].[method-you-exported].
            - You have the data. --> use it as per need.
    NOTE:
        - Don't Forget to handle data as undefined [i.e It's Still fetching the data] and data as null -> No Response from DB.

NOTE:
    - From Component Files we can named export. But from page.tsx, we always need to default export.

MileStone_1: 
    -- We are able to Login using Password, OAuth [github and google].
    -- We have a signIn and SignUp Page Built, With Input Validations and Database connected.
    -- We are able to Naviagte to our Home Landing Page, have Profile Badge Implement.
    -- Logout Functionality is Also Implemented.


** WorkSpace Creation Api and Modal: 

    -- New Table creation: [convex/schema.ts] --> Workspaces --> holds the name of workspace, who crated it and joinCode.
    -- install new package:
        1. jotai --> global state management.
        2. dialog --> From shadcn, ui component
    -- Write a workspace.ts [in Convex folder], then call the query from feature/workspaces/api/use-get-workspaces custom hook.
    -- Logically, In Landing Page,
        - If workSpace exists -> Go to that WorkSpace.
        - If workspace doesn't exist --> Open a modal for user to Create a Workspace.

## Create a Global state For the CreateWorkspaceModal with joti
    -- First create a new file --> feature/workspaces/store/use-create-workspace-modal.
    -- Then useAtom and atom from jotai and return the state.
    Why ?
        --> Basically to handle the modal, we can simply use useState boolean to handle it.
        --> But useState will be specific to that component alone.
        --> But with jotai, You just made a global state to control the modal state. *** coool ***

-- Now, Create a new component for the create Workspace Dialoge Modal, Add it in the Layout.ts under src/app.
    --> Better Way to handle more Modals:
        - create a new modals.tsx under src/app/components.
        - import all the modals, --> have a component that renders all the modals.
        - Add this in the layout.tsx file. 
    NOTE:
        To Prevent hyderation error with jotai, When they gets render with server-side my mistake.
        --> Solution: Make Sure the modals folder is client rendered --> useEffect and "useClient" Make it for sure client rendered.

## Create an api end point to handle creation of workspace:
    1. Handling the DB Insert:    
        -- we will go to convex/workspace.ts --> add a new method createWorkSpace.
        -- This will be mutation method i.e updating existing table.
            NOTE: use query method when you are just reading from the table.
        -- This Works with an args --> That is passed as param to the handler method.
        -- Returns the newly created workspaceId.
    2. Handle the api [contains workspace related hooks] under feature/workspace/api:
        -- use-get-workspaces: Fetches all the workspaces for the current loggedIn userId.
        -- use-create-workspace:
            - Very powerful custom hook.
            - Goal: To handle creation of new Workspace, all gives us the API states, like 
                    isPending [time taken for the cration of workspace] --> used to diable the buttons and input fields during workspace creation.
                    isSuccess -> Returns a success method, that holds the response as param. --> Can be used to determine what to do when the creation is successful.
                    isError -> In case of error --> holds the Error Object as param. --> Can be used to render a Error fallback screen.
                    isSettled -> Once the call is done, If any action, this method can be used.
        
        *** IMP: Best Example, how to write and use a Complex api custom hook with nextJs and Convex *** [use as reference]
    3. A WorkSpace Landing Page:
        - New folder added under app/workspace--> [workspaceId]/page.tsx  [** This is how dynamic rounting handled ***]
        - eg: /workspace/34242424 --> lands to the the above page.
        - that id can be extracted in PageProps Interface {params: {workspaceId: string}} [Note: The name here and the above in dynamic route must match]

TODO: [3rd Oct 2024]

** Workspace Landing Page:
    
    -- A new folder under src/hooks --> Holds the application level hooks.
    -- A new hook added: use-workspace-id.ts --> It extracts the workspaceId that is passed in Params and Returns it. 
    
    ** NOTE: 
        1. Make sure the above one it's a client component. 
        2. useEffect, useParams --> This will not work if you dont mention the file as "use client".
        3. "use client" --> Marks the boundary between a server-side rendered component and client-side rendered component.
            -- i.e once in parent component, you mark 'use client' --> and it renderes subsequent children components.
                --> then untill specified, all children will follow 'use client', and no need to explictly mention them inside each children component.
                --> thus, once you cross the boundary, you are good.
                --> Ref: src/workspace/[id]/layout --> our parent component --> that render all it's children like sidebar, toolbar etc. [we dont have 'use client'] --> but we are able to use hooks and state management.
            -- Interactive websites tends to follow majorly clinet-side rendering.
            -- Static read-only websites like blog posts, List of Itenary etc, where no user-interaction necessary can be server-side rendered. --> Just display Data to the user. 
        4. If a page is "use client" --> And it renders others children using the children prop --> Doesnot mean all children will be client rendered, It can be server-rendered also as long as "children" prop is used to render them.
    
    -- A new db api added in convex/workspace.ts --> getById --> Fetches workspace Info based on passed workspaceId.
    -- To Make the above call, create a customHook --> under feature/workspaces/api --> useQuery and fetch the data and apiState.
    -- In the [workspaceId]/page.tsx --> Make the Above call to fetch workspace releated Data.

    NOTE:
        -- Page.tsx is a reserved keyword in nextJs to build the landing Page.
        -- layout.tsx is also a reserved keyword to handle layout within the same route.
        -- Other reserved keywords: error, loading. EXcept these you can keep whatever file you want inside route folder.
    
    ** Why Layout Needed ? --> ** Handles Common code between subRoutes **
        -- somtime, We have reusable code, Inside the under same route. 
            eg: under /workspace/[workspaceId] --> we can have many routes. like workspace/[workspaceId]/channel or workspace/[workspaceId] etc
        -- So the layout holds common code like, sideBar or navbar that we want both of the above.
        -- Layout dont get re-render on Route chnages. --> Big Performance Improvement. [** IMP **]
        -- So To minimise code duplication and improve modularity, It's suggested to go ahead with layout 

TODO: [5th Oct 2024]

## Handling Layout for Workpace [app/workspace/[workspaceId]/layout.tsx]
    -- Like Page, It also requires a default layout. **IMP**
    -- Children:React.ReactNode --> Need to be added inside layout, so that it renders others route paths i.e [workspaceId]/page.tsx inside the parent Route [/workspace].
    -- Now, Add the common code among the Routes inside this layout.
    NOTE: Page.tsx and layout.tsx both will be under same Parent.

    1. Create a Toolbar:
        -- created --> /workspace/[workspaceId]/toolbar.tsx.
        -- Add it to the layout.tsx
    
    2. Creating a SideBar
        -- created --> /workspace/[workspaceId]/sidebar.tsx.
        -- Add it to the layout.tsx
        -- Include workspace-switcher component --> Have DropDown, Allows user to switch between the workspaces.
        -- Features of workspace-switchers:
            - Allows user to view his active workspace, along with other worspaces. [NOTE: all workspaces will show here.]
            - Allows him to navigate to a particular workspace.

** Issue: [Fixed]
    -- When we create a new Workspace --> it's redirecting to the new workspace -> but the click events on the entire page is not working.
    -- It is Woking when, we force reload the page.
    -- Problem: In create-workspace-modal.tsx file,
        --> After fetching the new workspace data, we are navigating using router.push from next/navigation.
        --> Seems like this is removing the events.
        --> no Error on the console.
    -- WorkAround,
        --> Instead of using router.push --> use window.location.assign() --> Navigates and reload the whole page. [** costly operation **]

    -- sol:
        -> If you using a dropdown + dialog --> Where you create the new workspace --> In DropdownMenu add propery modal={false}.
        -> should solve the events disabled issue.

    3. Sidebar buttons:
        -- created --> /workspace/[workspaceId]/sidebar-button.tsx.
        -- Shows various Buttons on the Sidebar with dedicated Icons and Functionality.
    NOTE:
        -- If using shadcn, and you need to conditionaly use tailwind classes. --> use cn()
        -- For reference: sidebar-button.tsx
        -- why ? 
            -- alternative way of doing that like {`isActive ? 'classes if it's true' : 'classses if it's false'`}
            -- High chances of getting conflict and might cause error.
        NOTE: *** shadcn must be installed ***

NOTE:
    -- the api, calls that we do for fetching data, Next not everytime, makes a call --> the response is usually cached. 
    -- Only when some chnages hanppens in the backend then only It makes a new call to fetch the data. 
    [Performance efficient]


NOTE: ** Important JS/React Things to Remember **
    -- const {data:workspace, isLoading:workspaceIsLoading} = Obj.
        --> here you destructure data and isLoading from Obj and also respectively renamed them. [** Awesome Implementation of JS **]
    -- eg: const [_open, setOpen] = useSomeHook();
        --> '_' infront of open is a way to say that, I am not going to use that varibale in the code.
    -- While defining interface for props for any component, If a prop is optional, define it like..
        interface DummyCompProps {
            prop1: string;
            prop2: boolean;
            prop3 ?: boolean;
        }
    --> In the above example, prop1 and prop2 are mandatory but prop3 is optional.

## Implementation of Member Functionality:
    -- New Schema Created --> members
    --> Each User will have it's own member profile --> That tells us about 2 things:
        1. the workspace he have access to.
        2. What kind of access he have ? "Admin" or "Member".
    -- Schema Changes to handle add data in members table, and query data from member table. --> convex/workspace.ts
    -- Code generation should be random, instead of some fix values.

    Functionality:
        -- If a user creates a new workspace --> He should be added as "Admin" to the memebers table.
    NOTE:
        -- Creating index while defining Schema --> helps to query faster. Ref --> convex/schema.ts
        -- For FetchData with "query" keyword in convex/workspace.ts --> Dont throw error, instead return empty value or null.
        -- For Creation with "mutation" keyword --> you can throw error. 

    Conclusion:
        -- users can create different workspaces and he can only view those workspace which he created.
        -- JoinCode is randomly generated, instead of hardCodded.

## Workspace sidebar Component: 
    -- new shadcn component added -> resizable. [provides resizable containers]
    -- channel Sidebar is added in app/workspace/[id]/layout.ts
    -- New component under app/workspace/[id]/workspaceSideBar.tsx
        -- New Query file --> under convex/members.ts.
        -- handle api:
            1. fetch the current member details based on loggedin UserId and WorkspaceId.
        -- New Members folder added -> under src/feature/members.
            -- new api folder --> use hook to handle the above fetch current member details.
    -- We need to handle the member and workspace calls and handle the fallback and loading screen accordingly.
    -- New shadcn component --> tooltip, new file created --> src/components/hint.tsx

NOTE: 
    -- "Jotai" --> the package that we use to maintain the state of Create-Workflow modal State throughout application.
    -- This needs proper Initialization in a next.js env.
    -- Added a new file under --> src/components/jotai-provider.tsx
    -- In src/app/layout.tsx i.e the main Layout --> Wrap the Children inside the JotaiProvider.

## Channel-sidebar Preferences: - src/app/workspace/[id]/preferences-modal.tsx
    -- Why ?
       --> Provides user Option with Renaming Workspace Or Remove Workspace --> Manage the Workspaces.
    -- preferences-modal.tsx --> New file added under src/app/workspace/[id]/preferences-modal.tsx.
    -- This will be included in the workspace-header.
    -- new update Workspace API [** handles updating workspace metaData i.e workspace preferences **]
    -- new remove workspace API.
        NOTE: When we remove a workspace --> all related entries and members associated with that workspace in members table --> must be removed.
    -- Remove Workspace..
        --> Ask User For Confirmation before deleting the workspace. --> customHook --> src/app/hooks/useUserConfirmation.tsx
            -- This is a generic Confirmation Modal custom-hook.
            -- Allows user to pass custom-message and Confirmation Title, and returns Promise based on user's selection.
            -- Ref: preferences-modal.tsx --> confirmation before deleting a workspace.
        --> once deleted Successfully, Dont keep the user on the same workspace, Re-direct him to '/' route. --> this will load the app/page.tsx --> Which loads the first active workspace under the current LoggedInUser.
    
** Issue: [fixed]
    - Say we are working with Dialoges and 
    - In my parent Component am maintaining a state that tracks the opening and closing of the dialoge.
    - Now I have another component that Where I used the dialogue and acception the states from parents as props.
    Problem:
        - the dialogue will open fine, On click on the Dialoge Trigger btn.
        - But when the dialogue will close, This is removing all the btns and click events from the Page.
        - then we need to reload the whole page, In order to click on the Dialoge Trigger btn again.
    
    Possible WorkAround: Ref: workspace-header.tsx [parent] --> preferences-modal.tsx[child that has Dialoge]
        - onOpenChange --> Pass a function that close the Modal, as well as reload the current page.
        - Drawback --> Very Costly Operation, The whole page is refreshed. ** Worst **
    
    ** Solution Found: 
        -> Problem was with dropDown + Dialog box implementation.
        -> Solution: In DropdownMenu --> add a property of 'modal' as 'false'.

NOTE:
    -- While working with Dialog from shadcn, use asChild attribute when you have big code inside the Trigger or content or footer.
    -- this prevents hyderation issues.
    
*** How to handle custom user Confirmation Hook *** [ VIMP ]    
    -- Very unique way of handling User-confirmation Modal using promises. [Ref: use-user-confirm.tsx]  **IMP**
       --> basically have a promise or null as state.
       --> one confirm should initialize the promise in the state, and cancel should make state null.
       --> Based on state is null or not --> show the confirmation Modal.
       --> If Cancel --> Make the promise in the state as resolved --> with false, if confrim --> resolve it with true.
       --> Reset the state to null --> this closes the confirmation popup.
       --> retrun The ConfrimationPop component and confirm method. 
       --> In Parent, confirm method opens the popup --> wait for the user to confrim/cancel --> i.e once resolved --> Either will true/false --> based on this, Operation can be handled in Parent.

--> workspace Admin can successfuly edit or remove the current workspace using Prefernces dropDown Option.

TODO: [12 Oct 2024]
## Channel-sidebar Show and Add new members:
    -- new SideItem Component Added --> contains ButtonLink with custom Variant --> Navigates to Channel id.
    -- Creating Channels
       -> New Schema Created --> channels --> Holds name, id [workspaceId] 
       -> also new index added to query by workspaceId.
    Rules: Everytime, we create a Workspace -> We must have atleast 1 Channel. --> Create a new Channel when we create a new workspace. -> Ref: createWorkspace method under convex/workspace.ts 
    -- Now channel function is ready --> create the hook to fetch those values.
       -> New file For Channels --> src/features/channels/api --> useGetChannels.ts [new hook]

    -- Wrap the Whole channel part inside it's workspaceSection --> To Seperate it from Other sidebarItems.
    -- It should show a Plus Icon to Add New channels with a hover Text.
    -- Also It should either hide or show all the Channels.
    -- New Package Added -> react-use  --> gives us a bunch of useful hooks --> WE will use useToggle hook.
    -- New Function Added -> under convex/members.ts --> fetch all the members for that workspace.
    -- Intergated in workspace-sidebar with workspace-section and user-Item component.


## Implentation of Add functionality for Channels and Members in sideBar.
-- What is Channel ?
    --> A table in backend that stores name of the channel and Workspace.
    --> So basically a user [only Admin] can create multiple channels and Add multiple members to that channel ?
    -- Created a Jotai --> global toggel For Add channel modal. ref: src/feature/channel/store/use-create-channal-modal.tsx.
    -- Create the Add Channel Modal --> under feature/channel/component/create-channel-modal.tsx.
    -- Since we managing all our modal at one place.
        -> will Add the new Modal to modal.tsx file under -> src/components/modal.tsx
    -- feature/Rule for new Channel Name:
        -> All words should be in one go i.e no spaces, if spaces convert them to '-'
    -- Craete a api end-point i.e convex function and use-create-channel hook -> Need to be created.

Thus, Able to Add new channels and list them under the side-bar. 


** Issue:  [fixed]
    -- SO the issue, Of Dialog box after closing, all the events are going away on the page. 
    -- It is not a problem with dialog box, It's a problem with the dropDown menu from shadcn.
    -- When using dropdown --> It opens the dialog box --> After the dialog box closes --> All events in that page is gone.
    -- It is happening whereever am using dropdownMenu + dialog from shadcn.
--> Github Issue Link: [https://github.com/shadcn-ui/ui/issues/468]

Finally: Solution: 
    --> In Dropdown menu --> Add a property of modal as 'false' If you are using DropDown Menu and on menu Click Opening a Modal.
    
[17th Oct 2024]    
-- Invite new Members Modal: [OnClick -> Invite members to current Project in sidebar]
    -- User Should be able to see a modal Window, With a Workspace Join Code and Copy the link to Join the Workspace.
    -- User should be able to reset the Join Code. [workspace.ts --> newJoinCode method] --> New hook created --> Used In invite-modal.ts









NOTE:
    -- Lucide Icons can be passed as Props to Child component. Ref: In workspace-sidebar component, we are passing "MessageSquareText" Licude Icon as Icon Prop.
        -> In the child comp, You must define the type as LucideIcon OR IconType -> from react-icon/lib.
        -> Also, As you destructure the Props, make sure to Map it to a variable with Caps to use as Component. Ref: sidebar-item.tsx
    -- "asChild" Property example. 
        --> If a button holds a link, And button you mark asChild. --> the button will behave like a Link.
        --> Prevents hyderation errors.
    -- using Link from next/Link --> Navigates to a particular URL. takes href.
    -- while using convex functions. Ref: convex/channels.ts
        -> after you write the query and withindex Chain. --> use collect() or unique() depending upon if the query will return multiple or unique rows.
    -- ml-auto or anything ml/mr/mt/mb-auto --> Will take all the space available on that respective side.
    -- opacity-0 or opacity-100 on hover can be used to handle the visibility.
    -- While Destructuring Obj, you can give default value to any key like eg: cosnt {key1, key2 = "myDefaultVal" } = Obj;  [** IMP **]
    -- Working with implementing hooks. [** VIMP **]
        -> Any hooks implementation must be the first thing in any component body.
        -> Ex: In workspace-sidebar.tsx, if i put the useCreateWorkspace hook at the last, It will throw error.
          1. It's better to put such kind of state or any hooks at the top.
          2. then write all the hooks used for api call and data fetching.
          3. then write the logic or data manipulation.
          4. then return the body of the Component. 
    -- 

[** IMP **]
    -- Working with convex Functions: Ref: convex/members.ts
        -> If Your fucntion returns array of data --> Check case if resp is null --> return [];
        -> If your function returns a unique data or ID --> check case if resp is null -> return null;
    -- Handling Multiple Tables with convex functions. [convex/members.ts/get method]
        -> Querying members table, based on userId --> I want to fetch the details from the user tables.
        -> This takes the ctx and the id --> using the id, it will fetch the details from the respective table.

Note: [on shadcn]
    -- We can create our own variant for button using "cva" instead of multiple if-else.. Ref: sidebar-item.tsx 
    -- import { cva, type VariantProps } from 'class-variance-authority'; --> You can see they have done the same in button.tsx under components/ui.
    -- Cleaner way of defining mutiple styles for button.      





MileStone_2:
    -- Now we are able to create a New Workspace and Land to that Workspace Route.
    -- Created the toolbar/navbar and sidebar UI. 
    -- Diffenet users with can create and view their own workspaces.
    -- workspace Admin can update workspace name or Remove the current workspace.
    -- Now we are able to view Channels [For newly created Workspaces] and Associated Members Options in the sidebar.